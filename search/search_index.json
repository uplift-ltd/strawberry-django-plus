{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"strawberry-django-plus","text":"<p>Enhanced Strawberry integration with Django.</p> <p>Built on top of strawberry-django integration, enhancing its overall functionality.</p> <p> </p>"},{"location":"#features","title":"Features","text":"<ul> <li> All supported features by <code>strawberry</code> and <code>strawberry-django</code>.</li> <li> Query optimizer extension       that automatically optimizes querysets       (using <code>only</code>/<code>select_related</code>/<code>prefetch_related</code>) to solve graphql <code>N+1</code> problems, with support       for fragment spread, inline fragments, <code>@include</code>/<code>@skip</code> directives, prefetch merging, etc</li> <li> Django choices enums using       support for better enum typing (requires       django-choices-field)</li> <li> Permissioned resolvers       using schema directives, supporting both       django authentication system,       direct and per-object permission checking for backends that implement those (e.g.       django-guardian).</li> <li> Mutations for Django,       with CRUD support and automatic errors validation.</li> <li> Relay support       for queries, connections and input mutations, all integrated with django types directly.</li> <li> Django Debug Toolbar integration with graphiql to       display metrics like SQL queries</li> <li> Improved sync/async resolver that priorizes the model's cache to avoid have to use       sync_to_async       when not needed.</li> <li> A well typed and documented API.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Install with pip:</p> <pre><code>pip install strawberry-django-plus\n</code></pre>"},{"location":"#how-to","title":"How to","text":"<p>You can now jump to the quickstart to learn how to use this lib.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>We use poetry to manage dependencies, to get started follow these steps:</p> <p><pre><code>git clone https://github.com/blb-ventures/strawberry-django-plus\ncd strawberry-django-plus\npoetry install\npoetry run pytest\n</code></pre> This will install all the dependencies (including dev ones) and run the tests.</p>"},{"location":"contributing/#pre-commit","title":"Pre commit","text":"<p>We have a configuration for pre-commit, to add the hook run the following command:</p> <pre><code>pre-commit install\n</code></pre>"},{"location":"contributing/#docs-setup-and-local-server","title":"Docs setup and local server:","text":"<p>We use Material for MkDocs, you can read the documentation here</p> <pre><code>make serve-docs\n</code></pre>"},{"location":"debug-toolbar/","title":"Django debug toolbar","text":"<p>This integration provides integration between the Django Debug Toolbar and <code>strawberry</code>, allowing it to display stats like <code>SQL Queries</code>, <code>CPU Time</code>, <code>Cache Hits</code>, etc for queries and mutations done inside the graphiql page.</p> <p>To use it, make sure you have the Django Debug Toolbar installed and configured, then change its middleware settings from:</p> <pre><code>MIDDLEWARE = [\n    ...\n    \"debug_toolbar.middleware.DebugToolbarMiddleware\",\n    ...\n]\n</code></pre> <p>To:</p> <pre><code>MIDDLEWARE = [\n    ...\n    \"strawberry_django_plus.middlewares.debug_toolbar.DebugToolbarMiddleware\",\n    ...\n]\n</code></pre> <p>Finally, ensure app <code>\"strawberry_django_plus\"</code> is added to your <code>INSTALLED_APPS</code> in Django settings.</p>"},{"location":"mutations/","title":"Mutations","text":"<p>This library provides 3 CUD mutations for streamlining common create/update/delete operations and reducing boilerplate code. There is also a facility for creating custom mutations with automatic <code>ValidationError</code> support.</p>"},{"location":"mutations/#cud-mutations","title":"CUD mutations","text":"<ul> <li><code>gql.django.create_mutation</code>: Will create the model using the data from the given input,   returning a <code>types.OperationInfo</code> if it fails with all raised <code>ValidationError</code> data.</li> <li><code>gql.django.update_mutation</code>: Will update the model using the data from the given input,   returning a <code>types.OperationInfo</code> if it fails with all raised <code>ValidationError</code> data.</li> <li><code>gql.django.delete_mutation</code>: Will delete the model using the id from the given input,   returning a <code>types.OperationInfo</code> if it fails with all raised <code>ValidationError</code> data.</li> </ul> <p>A simple complete example would be:</p> <pre><code>from strawberry_django_plus import gql\n\n@gql.django.type(SomeModel)\nclass SomeModelType(gql.Node):\n    name: gql.auto\n\n@gql.django.input(SomeModel)\nclass SomeModelInput:\n    name: gql.auto\n\n\n@gql.django.partial(SomeModel)\nclass SomeModelInputPartial(gql.NodeInput):\n    name: gql.auto\n\n@gql.type\nclass Mutation:\n    create_model: SomeModelType = gql.django.create_mutation(SomeModelInput)\n    update_model: SomeModelType = gql.django.update_mutation(SomeModelInputPartial)\n    delete_model: SomeModelType = gql.django.delete_mutation(gql.NodeInput)\n</code></pre>"},{"location":"mutations/#extending-build-in-cud-mutations","title":"Extending build in CUD mutations","text":"<p>There might be the need to perform some pre or post validation before running the built-in mutations. A common use case is for example setting a model field based on the current request context.</p> <p>As the syntax is not completely straightforward at the moment an example is listed as follows.</p> <pre><code>from django.conf import settings\nfrom django.db import models\n\n# Django Model\nclass Asset(models.Model):\n    name = models.TextField(null=True, blank=True)\n    owner = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, null=True, blank=True)\n</code></pre> <p>The strawberry code uses a relay implementation but the concept should also work in a non-relay context.</p> <pre><code>from strawberry_django_plus.mutations import resolvers\n\n@gql.django.type(Asset)\nclass AssetNode(gql.relay.Node):\n    name: gql.auto\n    owner: UserNode\n\n@gql.django.partial(Asset)\nclass UpdateAssetInput(gql.NodeInput):\n    name: gql.auto\n\n@gql.type\nclass ModelMutation:\n\n    @gql.mutation\n    def update_asset(self, info: Info, input: UpdateAssetInput) -&gt; ModelNode:\n        data = vars(input)\n        node_id: gql.relay.GlobalID = data.pop('id')\n        asset: Asset = node_id.resolve_node(info, ensure_type=Asset)\n\n        if asset.owner != info.context.request.user:\n            raise PermissionError(\"You can only modify objects you own.\")\n\n        return resolvers.update(info, asset, resolvers.parse_input(info, data))\n</code></pre> <p>Important to note is that the input has to be converted via <code>vars</code> call. The concept is taken from the built-in mutation. You then need to call the <code>resolvers.update</code> function to mutate the model instance. The main benefit is that you keep all the validation and update logic from the built-in mutation.</p>"},{"location":"mutations/#custom-model-mutations","title":"Custom model mutations","text":"<p>It is possible to create custom model mutations with <code>gql.django.input_mutation</code>, which will automatically convert the arguments to a input type and mark the return value as a union between the type annotation and <code>types.OperationInfo</code>. The later will be returned if the resolver raises <code>ValidationError</code>.</p> <p>For example:</p> <pre><code>from django.core.exceptions import ValidationError\nfrom strawberry_django_plus import gql\n\n@gql.type\nclass Mutation:\n    @gql.django.input_mutation\n    def set_model_name(self, info, id: GlobalID, name: str) -&gt; ModelType:\n        obj = id.resolve_node(info)\n        if obj.some_field == \"some_value\":\n            raise ValidationError(\"Cannot update obj with some_value\")\n\n        obj.name = name\n        obj.save()\n        return obj\n</code></pre>"},{"location":"query-optimizer/","title":"Query optimizer","text":"<p>The automatic optimization is enabled by adding the <code>DjangoOptimizerExtension</code> to your strawberry's schema config.</p> <pre><code>import strawberry\nfrom strawberry_django_plus.optimizer import DjangoOptimizerExtension\n\nschema = strawberry.Schema(\n    Query,\n    extensions=[\n        # other extensions...\n        DjangoOptimizerExtension,\n    ]\n)\n</code></pre> <p>Now consider the following:</p> <p>Example</p> modelsschemaquery for the artist fieldoptimized queryset for the artist fieldquery for the song fieldoptimized queryset for the song field <pre><code>class Artist(models.Model):\n    name = models.CharField()\n\n\nclass Album(models.Moodel):\n    name = models.CharField()\n    release_date = models.DateTimeField()\n    artist = models.ForeignKey(\"Artist\", related_name=\"albuns\")\n\n\nclass Song(models.Model):\n    name = model.CharField()\n    duration = models.DecimalField()\n    album = models.ForeignKey(\"Album\", related_name=\"songs\")\n</code></pre> <pre><code>from strawberry_django_plus import gql\n\n@gql.django.type(Artist)\nclass ArtistType:\n    name: auto\n    albums: \"List[AlbumType]\"\n\n\n@gql.django.type(Album)\nclass AlbumType:\n    name: auto\n    release_date: auto\n    artist: ArtistType\n    songs: \"List[SongType]\"\n\n\n@gql.django.type(Song)\nclass SongType:\n    name: auto\n    duration: auto\n    album_type: AlbumType\n\n\n@gql.type\nclass Query:\n    artist: Artist = gql.django.field()\n    songs: List[SongType] = gql.django.field()\n</code></pre> <pre><code>query {\n  artist {\n    id\n    name\n    albums {\n      id\n      name\n      songs {\n        id\n        name\n      }\n    }\n  }\n}\n</code></pre> <pre><code>Artist.objects.all().only(\"id\", \"name\").prefetch_related(\n    Prefetch(\n        \"albums\",\n        queryset=Album.objects.all().only(\"id\", \"name\").prefetch_related(\n            \"songs\",\n            Song.objects.all().only(\"id\", \"name\"),\n        )\n    ),\n)\n</code></pre> <pre><code>query {\n  song {\n    id\n    album\n    id\n    name\n    artist {\n      id\n      name\n      albums {\n        id\n        name\n        release_date\n      }\n    }\n  }\n}\n</code></pre> <pre><code>Song.objects.all().only(\n    \"id\",\n    \"album\",\n    \"album__id\",\n    \"album__name\",\n    \"album__release_date\",  # Note about this below\n    \"album__artist\",\n    \"album__artist__id\",\n).select_related(\n    \"album\",\n    \"album__artist\",\n).prefetch_related(\n    \"album__artist__albums\",\n    Prefetch(\n        \"albums\",\n        Album.objects.all().only(\"id\", \"name\", \"release_date\"),\n    )\n)\n</code></pre> <p>Note</p> <p>Even though <code>album__release_date</code> field was not selected here, it got selected in the prefetch query later. Since Django caches known objects, we have to select it here or else it would trigger extra queries latter.</p>"},{"location":"query-optimizer/#model-property","title":"Model property","text":"<p>It is possible to include hints for non-model fields using the field api or even our <code>@model_property</code> (or its cached variation, <code>@cached_model_property</code>) decorator on the model itself, for people who like to keep all the business logic at the model.</p> <p>For example, the following will automatically optimize <code>only</code> and <code>select_related</code> if that field gets selected:</p> <pre><code>from strawberry_django_plus import gql\n\nclass Song(models.Model):\n    name = models.CharField()\n\n    @gql.model_property(only=[\"name\", \"album__name\"], select_related=[\"album\"])\n    def name_with_album(self) -&gt; str:\n        return f\"{self.album.name}: {self.name}\"\n\n@gql.django.type(Song)\nclass SongType:\n    name: auto\n    name_with_album: str\n</code></pre> <p>Another option would be to define that on the field itself:</p> <pre><code>@gql.django.type(Song)\nclass SongType:\n    name: auto\n    name_with_album: str = gql.django.field(\n        only=[\"name\", \"album__name\"],\n        select_related=[\"album\"],\n    )\n</code></pre>"},{"location":"quickstart/","title":"Quick start","text":""},{"location":"quickstart/#introduction","title":"Introduction","text":"<p>Since this lib has a long name, it does provide a shortcut called <code>gql</code> where all of strawberry's API and ours can be accessed.</p> <pre><code>from strawberry_django_plus import gql\n\n# All strawberry's base api can be found directly on gql, like:\ngql.type  # same as strawberry.type\ngql.field  # same as strawberry.field\n...\n\n# The strawberry-django API and our custom implementation can be found on gql.django, like:\ngql.django.type\ngql.django.field\n...\n\n# We also have a custom relay implementation in here:\ngql.relay\n</code></pre>"},{"location":"quickstart/#how-to","title":"How To","text":""},{"location":"quickstart/#django-choices-enums","title":"Django Choices Enums","text":"<p>Convert choices fields into GraphQL enums by using Django Choices Field extension.</p> <pre><code>from django_choices_field import TexChoicesField\n\nclass Song(models.Model):\n    class Genre(models.TextChoices):\n        ROCK = \"rock\", \"Rock'n'Roll\"\n        METAL = \"metal\", \"Metal\"\n        OTHERS = \"others\", \"Who Cares?\"\n\n    genre = TextChoicesField(choices_enum=Genre)\n</code></pre> <p>In that example, a new enum called <code>Genre</code> will be created and be used for queries and mutations.</p> <p>If you want to name it differently, decorate the class with <code>@gql.enum</code> with your preferred name so that this lib will not try to register it again.</p>"},{"location":"quickstart/#standard-django-choices-enums","title":"Standard django choices enums","text":"<p>Convert standard django choices fields into GraphQL enums by dynamically creating an Enum class based on choices This feature can be enable by defining <code>STRAWBERRY_DJANGO_GENERATE_ENUMS_FROM_CHOICES</code> setting to <code>True</code></p> <pre><code>class Song(models.Model):\n    GENRE_CHOICES = (\n        (\"rock\", \"Rock'n'Roll\"),\n        (\"metal\", \"Metal\"),\n        (\"others\", \"Who Cares?\"),\n    )\n\n    genre = models.CharField(choices=GENRE_CHOICES)\n</code></pre> <p>In that example, a new enum called <code>MyAppSongGenreEnum</code> will be dynamically created and be used for queries and mutations.</p> <p>Have in mind that this approach don't let you re-use the dynamically created enum elsewhere.</p>"},{"location":"quickstart/#permissioned-resolvers","title":"Permissioned resolvers","text":"<p>Permissioning is done using schema directives by applying them to the fields that requires permission checking.</p> <p>For example:</p> <pre><code>@strawberry.type\nclass SomeType:\n    login_required_field: RetType = strawberry.field(\n        # will check if the user is authenticated\n        directives=[IsAuthenticated()],\n    )\n    perm_required_field: OtherType = strawberry.field(\n        # will check if the user has `\"some_app.some_perm\"` permission\n        directives=[HasPerm(\"some_app.some_perm\")],\n    )\n    obj_perm_required_field: OtherType = strawberry.field(\n        # will check the permission for the resolved value\n        directives=[HasObjPerm(\"some_app.some_perm\")],\n    )\n</code></pre> <p>Available options are:</p> <ul> <li><code>IsAuthenticated</code>: Checks if the user is authenticated (<code>user.is_autenticated</code>)</li> <li><code>IsStaff</code>: Checks if the user is a staff member (<code>user.is_staff</code>)</li> <li><code>IsSuperuser</code>: Checks if the user is a superuser (<code>user.is_superuser</code>)</li> <li><code>HasPerm(perms: str, list[str], any: bool = True)</code>: Checks if the user has any or all of   the given permissions (<code>user.has_perm(perm)</code>)</li> <li><code>HasRootPerm(perms: str | list[str], any: bool = True)</code>: Checks if the user has any or all   of the given permissions for the root of that field (<code>user.has_perm(perm, root)</code>)</li> <li><code>HasObjPerm(perms: str | list[str], any: bool = True)</code>: Resolves the retval and then   checks if the user has any or all of the given permissions for that specific value   (<code>user.has_perm(perm, retval)</code>). Note that if the return value is a list, this directive   will filter the return value, removing objects that fails the check (check below for more   information regarding other possibilities).</li> </ul> <p>There are some important notes regarding how the directives handle the return value:</p> <ul> <li>If the user passes the check, the retval is returned normally</li> <li>If the user fails the check:</li> <li>If the return type was <code>Optional</code>, it returns <code>None</code></li> <li>If the return type was a <code>List</code>, it returns an empty list</li> <li>If the return type was a relay <code>Connection</code>, it returns an empty <code>Connection</code></li> <li>If the field is a union with <code>types.OperationInfo</code> or <code>types.OperationMessage</code>, that type     is returned with a kind of <code>PERMISSION</code>, explaining why the user doesn't have permission     to resolve that field.</li> <li>Otherwise, it raises a <code>PermissionError</code> for that resolver, which will be available at     the result's <code>errors</code> field.</li> </ul> <p>Note that since <code>strawberry</code> doesn't support resolvers for schema directives, it is necessary to use this lib's custom extension that handles the resolution of those and any other custom defined schema directive inherited from <code>strawberry_django_plus.directives.SchemaDirectiveResolver</code>:</p> <pre><code>import strawberry\nfrom strawberry_django_plus.directives import SchemaDirectiveExtension\n\nschema = strawberry.Schema(\n    Query,\n    extensions=[\n        SchemaDirectiveExtension,\n        # other extensions...\n    ]\n)\n</code></pre>"},{"location":"quickstart/#relay-support","title":"Relay Support","text":"<p>We have a custom relay spec implementation. It is not tied to Django at all to allow its usage with other types.</p> <p>It provides types and fields for node and connection querying. For example:</p> <pre><code># schema.py\nfrom strawberry_django_plus import gql\nfrom strawberry_django_plus.gql import relay\n\n@gql.type\nclass Fruit(relay.Node):\n    name: str\n\n    def resolve_node(cls, node_id, info, required=False):\n        ...\n\n    def resolve_nodes(cls, node_id, info, node_ids=False):\n        ...\n\n\n@gql.type\nclass Query:\n    fruit: Optional[Fruit] = relay.node()\n    fruits_connection: relay.Connection[Fruit] = relay.connection()\n\n    @relay.connection\n    def fruits_connection_filtered(self, name_startswith: str) -&gt; Iterable[Fruit]:\n        # Note that this resolver is special. It should not resolve the connection, but\n        # the iterable of nodes itself. Thus, any arguments defined here will be appended\n        # to the query, and the pagination of the iterable returned here will be\n        # automatically handled.\n        ...\n</code></pre> <p>Will generate a schema like this:</p> <pre><code>interface Node {\n  id: GlobalID!\n}\n\ntype Fruit implements Node {\n  id: GlobalID!\n  name: String!\n}\n\ntype FruitEdge implements Node {\n  cursor: String!\n  node: Fruit\n}\n\ntype FruitConnection {\n  edges: [ShipEdge!]!\n  pageInfo: PageInfo!\n}\n\ntype PageInfo {\n  hasNextPage: Boolean!\n  hasPreviousPage: Boolean!\n  startCursor: String\n  endCursor: String\n}\n\ntype Query {\n  fruit(id: GlobalID!): Fruit\n  fruits_connection(\n    before: String\n    after: String\n    first: Int\n    last: Int\n  ): FruitConnection\n  fruits_connection_filtered(\n    before: String\n    after: String\n    first: Int\n    last: Int\n    nameStartswith: String!\n  ): FruitConnection\n}\n</code></pre> <p>It is expected that types implementing the <code>Node</code> interface define some methods, like <code>resolve_nodes</code> and <code>resolve_node</code>. By default the <code>id</code> field is used for the node id. This is customizable with the <code>id_attr</code> attribute. Take a look at the documentation for more information.</p> <p>Also note that Django fields created with <code>@gql.django.type</code> automatically implements all of the required methods when the type inherits from <code>Node</code>. By default the <code>pk</code> field is used for the node id (overwrites the default <code>id</code> field) but can also be customized with the <code>id_attr</code>attribute.</p> <p>This module also exposes a mutation that converts all of its arguments to a single input. For example:</p> <pre><code>@gql.type\nclass Mutation:\n    @relay.input_mutation\n    def create_fruit(name: str) -&gt; Fruit:\n        ....\n</code></pre> <p>Will generate those types:</p> <pre><code>input CreateFruitInput {\n  name: String!\n}\n\ntype Mutation {\n  createFruit(input: CreateFruitInput!): Fruit\n}\n</code></pre>"}]}